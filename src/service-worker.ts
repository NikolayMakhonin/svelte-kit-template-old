import localforage from 'localforage'
import { version, files, build, prerendered } from '$service-worker';

console.log('OK')
console.log({ version, files, build, prerendered })

const CACHES = {
	code: `code-${version}`,
	libs: `libs-4`,
	fonts: `fonts-1`,
	images: `images-1`,
	audios: `audios-3`,
	videos: `videos-1`,
	other: `other-${version}`,
}

async function sendMessage(message: any, transfer?: Transferable[]) {
	const windows = await ((self as any) as ServiceWorkerGlobalScope).clients.matchAll()
	windows.forEach(window => {
		try {
			window.postMessage(message, transfer)
		} catch (err) {
			console.error(err)
		}
	})
}

self.addEventListener('error', function(event) {
  // console.error(event.filename, event.lineno, event.colno, event.message, event.error);
  logError({
  	...event,
  	error: event.error && (event.error.stack || event.error + ''),
  })
})

self.addEventListener('unhandledrejection', function(event) {
  // @ts-ignore
	let { reason, detail } = event
  if (!reason && detail) {
    reason = detail.reason
  }

  if (reason instanceof Error) {
    logError(reason)
  } else {
    logError(
    	reason
				? reason.message || String(reason)
				: 'unhandled rejection was null or undefined!'
		)
  }
})

async function logError(error: any) {
  console.error(error);
	await sendMessage({
		type: 'error',
		error,
	})
}

// analytics
// async function goal(args: {
// 	category: string,
// 	action?: string,
// 	label?: string,
// 	value?: number,
// }) {
// 	await sendMessage({
// 		type: 'goal',
// 		args,
// 	})
// }

// analytics
// goal({
// 	category: 'service_worker',
// 	action: 'init_start',
// })

// `build` is an array of all the files generated by the bundler,
// `files` is an array of everything in the `static` directory
const to_cache = (build)
	.concat(files)
	.concat(prerendered);
console.log('to_cache', to_cache)
const staticAssets = new Set(to_cache);
const staticAssetsByCacheName = to_cache
	.reduce((a, o) => {
		const paths = a[getCacheName(o)]
		if (!paths) {
			a[getCacheName(o)] = [o]
		} else {
			paths.push(o)
		}
		return a
	}, {} as any)

function isStaticAsset(url: URL) {
	const _url = typeof url === 'string'
		? new URL(url, location.href)
		: url

	return _url.host === self.location.host && staticAssets.has(_url.pathname);
}

function getCacheName(url: URL|string): keyof typeof CACHES {
	const _url = typeof url === 'string'
		? new URL(url, location.href)
		: url

	url = _url.href

	if (_url.hostname === location.hostname && _url.port === location.port) {
		if (/\/$|\/index\.\w+$|^\/service-worker|^\/manifest\.json/.test(_url.pathname)) {
			return 'code'
		}
		if (prerendered.some(o => _url.pathname.endsWith(o))) {
			return 'code'
		}
		if (/^\/(client\/)?([^\/]+)\.(css|js|html|txt)$/.test(_url.pathname)) {
			return 'code'
		}
	}

	if (/\.(css|js)(\?.*)?$|\bgoogletagmanager\.com\/gtag\/js/.test(url)) {
		return 'libs'
	}

	if (/\.(ttf|otf|woff2?)(\?.*)?$|\bfonts\.googleapis\.com/.test(url)) {
		return 'fonts'
	}

	if (/\.(svg|png|ico|jpg|jpeg|gif|tif|tiff)(\?.*)?$/.test(url)) {
		return 'images'
	}

	if (/\.(mp3|ogg|wav)(\?.*)?$/.test(url)) {
		return 'audios'
	}

	if (/\.(mp4|avi|flv|webm)(\?.*)?$/.test(url)) {
		return 'videos'
	}

	// console.debug('Unknown asset detected: ' + url)

	return 'other'
}

function getExpirationPeriod(url: URL|string): number {
	const _url = typeof url === 'string'
		? new URL(url, location.href)
		: url

	const cacheName = getCacheName(url)
	if (cacheName === 'other') {
		return -1
	}

	if (/\/$|\/index\.\w+$|^\/service-worker|^\/manifest\.json/.test(_url.pathname)) {
		return 0
	}

	if (prerendered.some(o => _url.pathname.endsWith(o))) {
		return 0
	}

	if (isStaticAsset(_url)) {
		return 365 * 24 * 60 * 60
	}

	return 24 * 60 * 60
}

async function isExpired(url: URL|string, response: Response): Promise<boolean> {
	const _url = typeof url === 'string'
		? new URL(url, location.href)
		: url

	if (!response || response.status !== 200) {
		// analytics
		// await goal({
		// 	category: 'service_worker',
		// 	action: 'cache_not_found',
		// 	label: _url.href,
		// })
		return true
	}

	const expirationPeriod = getExpirationPeriod(_url)
	// const responseDateStr = response.headers.get('date')
	// const responseDate = responseDateStr && new Date(responseDateStr).getTime() || 0
	const responseDate = await getResponseDate(_url.href)
	if (responseDate && responseDate + expirationPeriod * 1000 >= Date.now()) {
		return false
	} else {
		console.debug('Cache Expired: ' + _url)
		return true
	}
}

self.addEventListener('install', (event: ExtendableEvent) => {
	// analytics
	// const goalPromise = goal({
	// 	category: 'service_worker',
	// 	action: 'install_start',
	// })

	const startTime = Date.now()

	event.waitUntil(Promise.all([
		// analytics
		// goalPromise,
		...Object.keys(CACHES)
			.map(async (key) => {
				const assets = staticAssetsByCacheName[key]
				if (assets && assets.length) {
					const cache = await caches.open(key)
					await Promise.all(assets.map(async url => {
						await cache.add(url)
						const responseDate = await getResponseDate(url)
						if (!responseDate) {
							await setResponseDate(url, Date.now())
						}
					}))
				}
			})])
			.then(async () => {
				await ((self as any) as ServiceWorkerGlobalScope).skipWaiting();
				// analytics
				// return goal({
				// 	category: 'service_worker',
				// 	action: 'install_completed',
				// 	value: Math.max(Date.now() - startTime, 1),
				// })
			}),
	);
});

self.addEventListener('activate', (event: ExtendableEvent) => {
	// analytics
	// const goalPromise = goal({
	// 	category: 'service_worker',
	// 	action: 'activate_start',
	// })

	const startTime = Date.now()

	event.waitUntil(Promise.all([
		// analytics
		// goalPromise,
		caches.keys().then(async keys => {
			// delete old caches
			const cachesIds = Object.keys(CACHES)
			for (const key of keys) {
				if (cachesIds.indexOf(key) < 0) {
					await caches.delete(key);
					await localforage.removeItem('cache_' + key)
				}
			}

			await ((self as any) as ServiceWorkerGlobalScope).clients.claim()

			// analytics
			// await goal({
			// 	category: 'service_worker',
			// 	action: 'activate_completed',
			// 	value: Math.max(Date.now() - startTime, 1),
			// })
		}),
	]));
});

const responseDates: {
	[key in keyof typeof CACHES]: {
		[key: string]: number
	}
} = {} as any

async function getResponseDates(cacheId: string) {
	let _responseDates = responseDates[cacheId]
	if (!_responseDates) {
		const json = await localforage.getItem<string>('cache_' + cacheId)
		responseDates[cacheId] = _responseDates = json && JSON.parse(json) || {}
	}
	return _responseDates
}

async function setResponseDates(cacheId: string, value: { [url: string]: number }) {
	await localforage.setItem('cache_' + cacheId, JSON.stringify(value))
}

async function getResponseDate(url: URL|string) {
	const _url = typeof url === 'string'
		? new URL(url, location.href)
		: url

	const cacheName = getCacheName(_url)
	const cacheId = CACHES[cacheName]
	const _responseDates = await getResponseDates(cacheId)
	return _responseDates[_url.href]
}

async function setResponseDate(url: URL|string, date: number) {
	const _url = typeof url === 'string'
		? new URL(url, location.href)
		: url

	const cacheName = getCacheName(_url)
	const cacheId = CACHES[cacheName]
	const _responseDates = await getResponseDates(cacheId)
	_responseDates[_url.href] = date
	await setResponseDates(cacheId, _responseDates)
}

/**
 * Fetch the asset from the network and store it in the cache.
 * Fall back to the cache if the user is offline.
 */
async function fetchWithCache(requestInfo: RequestInfo) {
	const url = typeof requestInfo === 'string'
		? requestInfo
		: requestInfo.url

	let request: Request
	if (typeof requestInfo !== 'string' && requestInfo.headers.has('range')) {
		request = requestInfo
		requestInfo = url
	}

	const expirationPeriod = getExpirationPeriod(url)
	let cachedResponse: Response = await caches.match(requestInfo)
	let expired = expirationPeriod <= 0 || await isExpired(url, cachedResponse)
	// analytics
	// await goal({
	// 	category: 'service_worker',
	// 	action: 'fetch_from_cache',
	// 	label: 'GET ' + url,
	// })
	let response: Response = cachedResponse && await getRangeableResponse(request, cachedResponse)

	async function _fetch() {
		let error
		try {
			const responseDate = Date.now()
			response = await fetch(requestInfo)
			if (response.status === 200) {
				if (expirationPeriod >= 0) {
					// response.headers.set('max-age', expirationPeriod.toString())
					const cacheName = getCacheName(url)
					const cache = await caches.open(cacheName)
					await cache.put(requestInfo, response.clone())
					await setResponseDate(url, responseDate)
					if (response.url !== url) {
						let _request
						if (typeof requestInfo === 'string') {
							_request = response.url
						} else {
							_request = requestInfo.clone()
							_request.url = response.url
						}
						await cache.put(request, response.clone())
						await setResponseDate(response.url, responseDate)
					}
				}
				response = await getRangeableResponse(request, response);
			}
		} catch (err) {
			error = err
		}

		if (error || !response || !response.ok) {
			if (!cachedResponse || cachedResponse.status !== 200) {
				cachedResponse = await caches.match(requestInfo);
			}
			if (cachedResponse && (!response || cachedResponse.status === 200)) {
				response = await getRangeableResponse(request, cachedResponse);
			}

			const cacheName = getCacheName(url)
			if (cacheName !== 'other') {
				// analytics
				// await goal({
				// 	category: 'service_worker',
				// 	action: 'fetch_error',
				// 	label: 'GET ' + url,
				// })
			}

			if (!response) {
				throw error;
			}
		}

		return response
	}

	if (!response || !response.ok) {
		return _fetch()
	}
	if (expired) {
		_fetch()
			.catch(err => {
				console.error(err)
			})
	}
	return response
}

self.addEventListener('fetch', (event: FetchEvent) => {
	const cacheName = getCacheName(event.request.url)

	const startTime = Date.now()

	// analytics
	// let goalPromise

	if (cacheName !== 'other') {
		// analytics
		// goalPromise = goal({
		// 	category: 'service_worker',
		// 	action: 'fetch_start',
		// 	label: event.request.method + ' ' + event.request.url,
		// })
	}

	if (event.request.method !== 'GET') {
		// analytics
		// goalPromise && event.waitUntil(goalPromise)
		return;
	}
	// if (event.request.headers.has('range')) {
	// 	console.warn('fetch range: ' + event.request.url)
	// 	return
	// }

	switch (cacheName) {
		case 'audios':
		// case 'videos':
			break
		default:
			if (event.request.headers.has('range')) {
				// analytics
				// goalPromise && event.waitUntil(goalPromise)
				return
			}
			break
	}

	const url = new URL(event.request.url);

	// don't try to handle e.g. data: URIs
	const isHttp = url.protocol.startsWith('http');
	const isDevServerRequest = url.hostname === self.location.hostname && url.port !== self.location.port;
	// const isStaticAsset = url.host === self.location.host && staticAssets.has(url.pathname);
	const skipBecauseUncached = event.request.cache === 'only-if-cached'; // && !isStaticAsset;

	if (isHttp && !isDevServerRequest && !skipBecauseUncached) {
		event.respondWith(
			(async () => {
				// always serve static files and bundler-generated assets from cache.
				// if your application has other URLs with data that will never change,
				// set this variable to true for them and they will only be fetched once.
				// const cachedAsset = isStaticAsset && await caches.match(event.request);

				// for pages, you might want to serve a build `service-worker-index.html` file,
				// which Sapper has generated for you. It's not right for every
				// app, but if it's right for yours then uncomment this section
				/*
				if (!cachedAsset && url.origin === self.origin && prerendered.find(route => route.pattern.test(url.pathname))) {
					return caches.match('/service-worker-index.html');
				}
				*/

				const [response] = await Promise.all([
					// analytics
					// goalPromise,
					fetchWithCache(event.request),
				]);

				// analytics
				// if (cacheName !== 'other' && response.ok) {
				// 	await goal({
				// 		category: 'service_worker',
				// 		action: 'fetch_completed',
				// 		label: event.request.method + ' ' + event.request.url,
				// 		value: Math.max(Date.now() - startTime, 1),
				// 	})
				// }

				return response
			})()
		);
	}
});

function getRangeableResponse(request, resp){
	// Return the response, obeying the range header if given
	// NOTE: Does not support 'if-range' or multiple ranges!
	// TODO: Temporary implementation, waiting on official fix:
	// https://github.com/whatwg/fetch/issues/144
	// https://github.com/slightlyoff/ServiceWorker/issues/703

	// Validate range value (return whole resp if null or invalid)
	if (!request) {
		return resp
	}

	if (!request.headers.get('range')) {
		return resp
	}

	// return createPartialResponse(request, resp)

	let range = /^bytes=(\d*)-(\d*)$/gi.exec(request.headers.get('range'))
	if (range === null || (range[1] === '' && range[2] === '')) {
		return resp
	}

	// Get the body as an array buffer
	return resp.arrayBuffer().then(function(ab){
		let total = ab.byteLength
		let start = parseInt(range[1], 10)
		let end = parseInt(range[2], 10)
		// Handle no start value (end is therefore an _offset_ from real end)
		// NOTE: testing on range var, as start/end Number('') -> 0
		if (range[1] === ''){
			start = total - end
			end = total - 1
		}
		// Handle no end value
		if (range[2] === ''){
			end = total - 1
		}
		const data = ab.slice(
			Math.max(0, Math.min(start, end + 1, total)),
			Math.max(0, Math.min(end + 1, total)),
		)
		// Add range headers to response's headers
		let headers = new Headers()
		for (let [k, v] of resp.headers) {
			headers.set(k, v)
		}
		headers.set('Content-Range', `bytes ${start}-${end}/${total}`)
		headers.set('Content-Length', data.byteLength.toString())
		// Return ranged response
		return new Response(data, {
			'status': 206,
			'statusText': 'Partial Content',
			'headers': headers,
		})
	})
}

// analytics
// goal({
// 	category: 'service_worker',
// 	action: 'init_completed',
// })
